# ================================================
# 1. DATA SPLITTING VALIDATION
# ================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

pd.set_option("display.max_columns", 50)

# user_id, item_id, rating (optional), timestamp
df = interactions.copy()

# N·∫øu timestamp ch∆∞a d·∫°ng datetime ‚Üí convert:
df["timestamp"] = pd.to_datetime(df["timestamp"], unit="s", errors="coerce")

# ------------------------------------------------------------
# 1.1 Check timestamp range
# ------------------------------------------------------------
print("\nTimestamp range:")
print(df["timestamp"].min(), "‚Üí", df["timestamp"].max())

plt.figure(figsize=(10,4))
sns.histplot(df["timestamp"], bins=50)
plt.title("Timestamp Distribution")
plt.xlabel("Time")
plt.ylabel("Count")
plt.show()

# ------------------------------------------------------------
# 1.2 Leave-Last-Out vs Timestamp Split
# ------------------------------------------------------------

# Leave-Last-Out: m·ªói user l·∫•y interaction cu·ªëi l√†m test
df_sorted = df.sort_values(["user_id", "timestamp"])
df["rank"] = df_sorted.groupby("user_id")["timestamp"].rank(method="first", ascending=False)

test_LLO = df[df["rank"] == 1]
train_LLO = df[df["rank"] > 1]

print("\nLeave-Last-Out Split:")
print("Train size:", len(train_LLO))
print("Test size:", len(test_LLO))


# Timestamp split (80/10/10 ho·∫∑c t√πy b·∫°n)
split_point_1 = df["timestamp"].quantile(0.8)
split_point_2 = df["timestamp"].quantile(0.9)

train_TS = df[df["timestamp"] <= split_point_1]
val_TS = df[(df["timestamp"] > split_point_1) & (df["timestamp"] <= split_point_2)]
test_TS = df[df["timestamp"] > split_point_2]

print("\nTimestamp Split:")
print("Train:", len(train_TS))
print("Val:", len(val_TS))
print("Test:", len(test_TS))

# ------------------------------------------------------------
# 1.3 Compare splits
# ------------------------------------------------------------
print("\nOverlap ratio between Leave-Last-Out test vs Timestamp test:")
overlap = len(set(test_LLO.item_id).intersection(set(test_TS.item_id))) / len(set(test_TS.item_id))
print("Overlap:", round(overlap, 4))

print("\nüîç Summary:")
print(f"- #Users: {df.user_id.nunique()}")
print(f"- #Items: {df.item_id.nunique()}")

# ------------------------------------------------------------
# 2.1 Compute history length for each user
# ------------------------------------------------------------
user_history_len = df.groupby("user_id").size().reset_index(name="history_len")

print("\nHistory length stats:")
print(user_history_len["history_len"].describe())

# ------------------------------------------------------------
# 2.2 Distribution plot
# ------------------------------------------------------------
plt.figure(figsize=(7,4))
sns.histplot(user_history_len["history_len"], bins=50, log_scale=True)
plt.title("Distribution of User History Length (log scale)")
plt.xlabel("#Interactions per user")
plt.ylabel("Count")
plt.show()

# ------------------------------------------------------------
# 2.3 Check percentage of users with too-short history
# ------------------------------------------------------------
short_1 = (user_history_len["history_len"] <= 1).mean()
short_2 = (user_history_len["history_len"] <= 2).mean()
short_5 = (user_history_len["history_len"] <= 5).mean()

print("\nUsers with short history:")
print(f"Users with ‚â§1 interaction: {short_1*100:.2f}%")
print(f"Users with ‚â§2 interactions: {short_2*100:.2f}%")
print(f"Users with ‚â§5 interactions: {short_5*100:.2f}%")

# ------------------------------------------------------------
# 2.4 Plot boxplot
# ------------------------------------------------------------
plt.figure(figsize=(6,4))
sns.boxplot(x=user_history_len["history_len"])
plt.title("User History Length Boxplot")
plt.xlabel("History length")
plt.show()
